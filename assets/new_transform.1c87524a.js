var V=Object.defineProperty;var S=(e,t,s)=>t in e?V(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s;var o=(e,t,s)=>(S(e,typeof t!="symbol"?t+"":t,s),s);import{m as h,r as c,g as p}from"./matrix.8c196d23.js";class Z{constructor(t){o(this,"el");o(this,"ctx");o(this,"width");o(this,"height");o(this,"degree_y");const s=t.clientWidth,i=t.clientWidth;t.width=s,t.height=i,this.el=t,this.ctx=t.getContext("2d"),this.width=s,this.height=i,this.degree_y=0}mirror_coordinate(){this.el.style.transformOrigin="center",this.el.style.transform="scale(1,-1)"}translate_origin(t){typeof t=="string"?(t=I(t,this),M(t,this.ctx)):M(t,this.ctx)}draw_point(t,s=1){this.ctx.beginPath(),this.ctx.fillStyle="#000",this.ctx.arc(t[0],t[1],s,0,2*Math.PI),this.ctx.fill(),this.ctx.closePath()}draw_line(t,s){this.ctx.beginPath(),this.ctx.moveTo(t[0],t[1]),this.ctx.lineTo(s[0],s[1]),this.ctx.stroke(),this.ctx.closePath()}draw_vector_order(t){for(let s=0;s<t.length;s++){const i=(s+1)%t.length;this.draw_line(t[s],t[i])}}draw_x(){this.draw_line(u(-this.width/2,0),u(this.width/2,0))}draw_z(){this.draw_line(u(0,-this.height/2),u(0,this.height/2))}draw_y(t){const s=t&&(this.degree_y=-t)&&this.degree_y||this.degree_y;let i,r;F(s)?(i=this.width/2,r=this.width/2*Math.tan(s/180*Math.PI)):(r=this.height/2,i=this.height/2/Math.tan(s/180*Math.PI)),this.draw_line(u(-i,-r),u(i,r))}clear_ctx(){this.ctx.clearRect(-this.width,-this.height,this.width*2,this.height*2)}}function m(e,t){return e=e%360,Math.abs(Math.abs(e)-t)}function F(e){return m(e,0)<=45||m(e,180)<=45}function u(e,t){return[e,t]}function I(e,t){const s=t.el.width,i=t.el.height;switch(e){case"center":return{x:s/2,y:i/2};default:return{x:0,y:0}}}function M(e,t){t.translate(e.x,e.y)}function A(e){return[[e[0],0],[0,e[1]]]}function q(e,t){let s;return t.length==2?s=h(A(e)):(s=[],console.error("don't support matrix 3 x 3 now")),c(t,s)}function $(e,t){return t.map(s=>q(e,s))}function C(e){return[[Math.cos(e),Math.sin(e)],[-Math.sin(e),Math.cos(e)]]}function E(e,t){let s;return e=_(e),t.length==2?s=h(C(e)):(s=[],console.error("don't support matrix 3 x 3")),c(t,s)}function tt(e,t){return t.map(s=>E(e,s))}function O(e){return[[1,0],[Math.tan(_(e)),1]]}function R(e){return[[1,Math.tan(_(e))],[0,1]]}function v(e,t){const[s,i]=e;return N(i,H(s,t))}function H(e,t){const s=h(O(e));return c(t,s)}function N(e,t){const s=h(R(e));return c(t,s)}function st(e,t){return t.map(s=>v(e,s))}const W=[[1,0],[0,-1]],j=[[-1,0],[0,1]];function k(e,t){let s;return t.length==2?e==1?s=h(W):e==-1?s=h(j):(s=[],console.error("don't get a available factor")):(s=[],console.error("don't support matrix 3 x 3")),c(t,s)}function et(e,t){return t.map(s=>k(e,s))}function _(e){return e/180*Math.PI}function U(e){return e.map(t=>(t.push(1),t))}function X(e){return e.push(1),e}function Y(e,t){const s=X(t),i=U([[1,0],[0,1]]);return i.push([...e,1]),c(s,h(i))}function it(e,t){return t.map(s=>Y(e,s)).map(s=>s==null?void 0:s.slice(0,s.length-1))}function rt(e){return parseFloat(e.value)}function nt(e){const s=e.value.split(",").slice();return s.length>2&&console.warn("only use the first and second factor"),s.length==1&&(s[1]=s[0]),s.map(i=>parseFloat(i))}function ot(e){const t=e.value.trim();return t=="x"?1:t=="y"?-1:console.error("error input factor on mirror transform")}function at(e){const s=e.value.split(",").slice();if(s.length>4){console.error("can only put 4 factors");return}const[i,r,n,a]=s.map(l=>parseFloat(l));if(s.length==4||s.length==3)return f(i,r,n,a);console.error("miss too much factors")}function B(e,t){const s=e.length,i=t.length;if(e.length!==t.length)return!1;{const r=Math.max(s,i);for(let n=0;n<r;n++){const a=e[n],l=t[n];if(a===void 0||l===void 0)return!1;if(a!==l)return!1}}return!0}function f(e,t,s,i=0){return[e,t,s,i]}class ht{constructor(t){o(this,"bodys");o(this,"axis");o(this,"aspect_rate");this.axis=f(0,1,0),this.aspect_rate=t}Add_body(t){this.bodys||(this.bodys=[]),this.bodys.push(t)}draw(){const t=this.bodys||[];if(t.length)for(let s=0;s<t.length;s++)t[s].draw()}rotate(t,s){const i=this.bodys||[];if(i.length)for(let r=0;r<i.length;r++)i[r].rotate(t,s||this.axis)}}class ct{constructor(t,s){o(this,"aspects");o(this,"d_ctx");o(this,"origin_aspects");o(this,"axis");o(this,"start_angle");this.aspects=t,this.origin_aspects=t.map(i=>i.map(r=>r.slice())),this.d_ctx=s,this.axis=f(0,1,0),this.start_angle=0}draw(t){const s=this.aspects[0].map(r=>w(r)),i=this.aspects[1].map(r=>w(r));y(s,this.d_ctx),y(i,this.d_ctx),G(s,i,this.d_ctx)}rotate(t,s){s=J(s||this.axis),B(this.axis,s)||(this.axis=s,this.start_angle=t,this.origin_aspects=this.aspects);const i=_(t-this.start_angle),r=this.axis[0],n=this.axis[1],a=this.axis[2],l=h([[r**2*(1-Math.cos(i))+Math.cos(i),r*n*(1-Math.cos(i))+a*Math.sin(i),r*a*(1-Math.cos(i)-n*Math.sin(i)),0],[r*n*(1-Math.cos(i))-a*Math.sin(i),n**2*(1-Math.cos(i))+Math.cos(i),n*a*(1-Math.cos(i)+r*Math.sin(i)),0],[r*a*(1-Math.cos(i))+n*Math.sin(i),a*n*(1-Math.cos(i))-r*Math.sin(i),a**2*(1-Math.cos(i))+Math.cos(i),0],[0,0,0,1]]),x=(this.aspects[0][0][0]-this.aspects[0][2][0])/2,g=(this.aspects[0][0][1]-this.aspects[1][0][1])/2,d=(this.aspects[0][0][2]-this.aspects[0][1][2])/2,b=p(f(-x,-g,-d,1)),P=p(f(x,g,d,1)),T=this.origin_aspects.map(z=>z.map(D=>K(D,b,l,P)));this.aspects=T}translate(t){const s=p(t),i=this.aspects.map(r=>r.map(n=>(n[3]=1,c(n,s))));console.log(i),this.origin_aspects=i,this.aspects=i}}function w(e){return e.slice(0,2)}function y(e,t){e.forEach((s,i)=>{const r=(i+1)%e.length;t.draw_line(s,e[r])})}function G(e,t,s,i){i=i||e.map((r,n)=>n),i.forEach((r,n)=>{s.draw_line(e[n],t[r])})}function lt(...e){return[...e]}function J(e){const t=Math.sqrt(e.reduce((s,i)=>s+i**2,0));return e.map(s=>s/t)}function K(e,...t){return t.reduce((s,i)=>c(s,i),e)}export{B as A,Z as D,lt as N,ht as O,ct as S,f as V,nt as a,rt as b,st as c,ot as d,it as e,at as i,et as m,tt as r,$ as s};
